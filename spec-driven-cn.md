# 以规范为核心的开发（SDD）

## 权力的逆转

几十年来，代码一直是软件开发的核心。规范只是为代码服务的工具——它们像脚手架一样，搭建好后就被丢弃，真正的“工作”始终是写代码。我们编写产品需求文档（PRD）来指导开发，撰写设计文档辅助实现，绘制架构图帮助理解系统结构。但这些内容始终只是代码的附属品。代码才是唯一的“真理”，其他一切充其量只是美好的愿望。代码是事实的唯一来源，随着代码不断演进，规范往往难以同步。由于资产（代码）与实现本身合二为一，想要在代码之外做并行实现几乎不可能。

以规范为核心的开发（SDD）彻底颠覆了这种权力结构。不是规范服务于代码，而是代码服务于规范。产品需求文档（PRD）不再只是实现的参考，而是直接生成实现的源头。技术方案不再只是指导开发的文档，而是能够精确定义并产出代码的蓝图。这不仅仅是对现有开发方式的小修小补，而是对软件开发驱动力的根本性重塑。

规范与实现之间的鸿沟，自软件开发诞生以来就一直困扰着我们。我们尝试用更完善的文档、更细致的需求、更严格的流程来弥合这道裂缝。但这些方法都默认了“鸿沟不可避免”，只能尽量缩小，却无法消除。而SDD则通过让规范及其衍生的实现方案具备可执行性，彻底消除了这道鸿沟。当规范和实现方案能够直接生成代码时，规范与实现之间不再有缝隙，只有“转化”过程。

如今，这种转化成为可能，是因为AI已经能够理解并实现复杂的规范，甚至生成详细的实现方案。但如果没有结构化的约束，AI的生成只会带来混乱。SDD通过精确、完整、无歧义的规范和实现方案，为AI生成提供了坚实的结构。规范成为最核心的产物，代码则是规范在特定语言和框架下的具体表达（即由实现方案生成的实现）。

在这个新世界里，维护软件的核心任务就是不断完善和演进规范。开发团队的意图通过自然语言（即“意图驱动开发”）、设计资产、核心原则和各种指导方针来表达。开发的“通用语言”提升到了更高的层次，代码只是最后一公里的实现手段。

调试，就是修正那些生成错误代码的规范和实现方案。重构，就是为了让规范和实现方案更清晰。整个开发流程都围绕规范这一唯一事实来源重组，实现方案和代码则是不断再生的产物。无论是为应用添加新功能，还是因为创造力而开发新的并行实现，都意味着回到规范，制定新的实现方案。这个过程本质上是从0到1，再到1'、2、3，直至N的演进。

开发团队的重心，回归到创造力、实验精神和批判性思维上。

## SDD 实践流程

整个流程始于一个想法——往往模糊且不完整。通过与AI的反复对话，这个想法逐步被打磨成一份详尽的产品需求文档（PRD）。AI会主动提问，澄清细节，识别边界情况，并协助定义精准的验收标准。传统开发中需要数天会议与文档工作的内容，如今只需数小时的专注讨论即可完成。这种方式彻底改变了传统的软件开发生命周期（SDLC）：需求和设计不再是割裂的阶段，而是持续进行的活动。这也非常适合团队协作——团队成员共同审查、版本化规范文档，像代码一样在分支中创建、合并。

当产品经理更新验收标准时，实施计划会自动标记受影响的技术决策。架构师发现更优的设计模式后，PRD也会随之更新，反映新的可能性。

在整个规范制定过程中，研究代理会收集关键背景信息，调查库的兼容性、性能基准和安全影响。组织层面的约束也会被自动发现并应用——公司的数据库标准、认证要求和部署政策都会无缝集成进每一份规范。

基于PRD，AI会生成实施计划，将需求映射到具体的技术决策。每一个技术选择都有详细的理由，每一项架构决策都能追溯到明确的需求。在整个过程中，规范的一致性会被持续校验，从而不断提升质量。AI会分析规范中的歧义、矛盾和遗漏——这不是一次性的检查，而是持续优化的过程。

只要规范和实施计划足够稳定，代码生成就可以启动，并不要求所有内容都“完备”。早期生成的代码可能只是探索性的，用于验证规范在实际中的可行性。领域概念会转化为数据模型，用户故事变成API接口，验收场景则直接生成测试用例。开发与测试在规范驱动下融为一体——测试场景不是在代码完成后才编写，而是规范的一部分，同时生成实现和测试。

反馈机制也不仅限于初始开发阶段。生产环境中的指标和事故不仅仅触发紧急修复，还会反向更新规范，为下一轮生成做准备。性能瓶颈会转化为新的非功能性需求，安全漏洞则成为影响未来所有版本的约束条件。规范、实现与运维之间的反复迭代，才是真正理解产品的过程，也是传统SDLC向持续演进转变的关键。

## 为什么现在需要SDD

有三大趋势让SDD（规范驱动开发）不仅成为可能，更是必然：

首先，AI能力已经达到一个新高度，自然语言规范可以稳定地产生可用代码。这并不是要取代开发者，而是通过自动化规范到实现的机械性转化，大幅提升开发者的效率。AI能极大地拓展探索和创新空间，支持“从头再来”，也便于增删和批判性思考。

其次，软件复杂度正呈指数级增长。现代系统集成了大量服务、框架和依赖，靠人工流程来保证各部分与最初意图一致变得越来越难。SDD通过规范驱动的自动生成，实现了系统性的对齐。未来的开发框架也许会优先支持AI，而不是以人为中心，或围绕可复用组件进行架构设计。

第三，变化的速度正在加快。如今，需求变化的频率远超以往。转向（pivot）已不再是例外，而是常态。现代产品开发要求根据用户反馈、市场环境和竞争压力快速迭代。传统开发模式则把这些变化视为干扰，每一次转向都需要手动在文档、设计和代码中同步变更。结果要么是缓慢而谨慎的更新，牺牲开发速度；要么是仓促而草率的修改，积累技术债务。

SDD（规范驱动开发）能够支持“假设/模拟”实验，比如：“如果我们需要重新实现或调整应用，以满足业务需求、提升T恤销量，我们该如何设计和验证方案？”

SDD将需求变更从障碍转变为日常流程。当规范驱动实现时，转向就变成了系统性的自动再生成，而不是手动重写。只需在PRD（产品需求文档）中修改核心需求，相关的实现方案会自动更新。调整用户故事，相应的API接口也会自动重建。这不仅仅是初始开发的问题，更是如何在不断变化中保持工程效率的关键。

## 核心原则

**规范为通用语言**：规范成为主要的产出物，代码只是用特定语言和框架对规范的表达。维护软件的本质就是不断完善规范。

**可执行规范**：规范必须足够精确、完整且无歧义，以便直接生成可运行的系统，从而消除意图与实现之间的鸿沟。

**持续完善**：一致性校验是持续进行的，而不是一次性的门槛。AI会持续分析规范，发现歧义、矛盾和遗漏。

**研究驱动的上下文**：研究代理在规范制定过程中不断收集关键上下文，调查技术选项、性能影响和组织约束。

**双向反馈**：生产环境的实际情况反过来推动规范的演进。各类指标、事故和运维经验都成为规范优化的输入。

**分支探索**：从同一份规范生成多种实现方案，探索不同的优化目标——如性能、可维护性、用户体验、成本等。

## 实施方法

目前，实践SDD需要整合现有工具，并在整个流程中保持规范优先的原则。常用方法包括：

- 利用AI助手进行迭代式规范开发
- 通过研究代理收集技术背景信息
- 使用代码生成工具将规范转化为实现
- 采用适配规范优先流程的版本控制系统
- 借助AI分析规范文档，持续校验一致性

关键在于把规范视为唯一真实的源头，代码只是根据规范自动生成的产物，而不是反过来。

## 用Claude命令简化SDD流程

SDD方法论通过两条强大的Claude命令实现了规范与规划流程的自动化：

### `new_feature` 命令

该命令可将简单的功能描述（用户输入）转化为完整、结构化的规范，并自动管理代码库：

1. **自动编号**：扫描现有规范，确定下一个功能编号（如001、002、003）
2. **分支创建**：根据描述自动生成语义化分支名并创建分支
3. **模板生成**：复制并定制功能规范模板，自动填充你的需求
4. **目录结构**：自动建立 `specs/[branch-name]/` 目录，归档所有相关文档

### `generate_plan` 命令

当功能规范已存在后，该命令会生成一份完整的实现方案：

1. **需求分析**：仔细研读并理解功能需求、用户故事和验收标准。
2. **合规性检查**：确保所有内容符合项目章程和架构原则。
3. **技术转化**：将业务需求转化为技术架构和具体实现细节。
4. **详细文档编写**：为数据模型、API协议和测试场景等生成配套文档。
5. **手工测试方案**：为每个用户故事制定详细的验证步骤。

### 示例：构建聊天功能

以下展示了这些命令如何革新传统开发流程：

**传统流程：**
```
1. 在文档中撰写PRD（2-3小时）
2. 编写设计文档（2-3小时）
3. 手动搭建项目结构（30分钟）
4. 撰写技术规格说明（3-4小时）
5. 制定测试计划（2小时）
总计：约12小时文档工作
```

**基于命令的SDD流程：**
```bash
# 第一步：创建功能规格说明（5分钟）
/new_feature 实时聊天系统，支持消息历史与用户在线状态

# 系统自动完成：
# - 创建分支 "003-chat-system"
# - 生成 specs/003-chat-system/feature-spec.md
# - 自动填充结构化需求内容

# 第二步：生成实现方案（10分钟）
/generate_plan 使用WebSocket实现实时消息，PostgreSQL存储历史，Redis管理在线状态

# 系统自动生成：
# - specs/003-chat-system/implementation-plan.md
# - specs/003-chat-system/implementation-details/
#   - 00-research.md（WebSocket库对比分析）
#   - 02-data-model.md（消息与用户数据结构）
#   - 03-api-contracts.md（WebSocket事件与REST接口）
#   - 06-contract-tests.md（消息流转测试场景）
#   - 08-inter-library-tests.md（数据库与WebSocket集成测试）
# - specs/003-chat-system/manual-testing.md
```

15分钟内，你就能获得：
- 包含用户故事和验收标准的完整功能规格
- 详细的实现方案，涵盖技术选型及其理由
- 可直接用于代码生成的API协议和数据模型
- 自动化与手工测试的全套测试场景
- 所有文档均在功能分支中妥善管理和版本控制

### 结构化自动化的威力

这些命令不仅节省时间，更保证了规范和完整性：

1. **无遗漏细节**：模板确保从非功能需求到异常处理都被覆盖
2. **决策可追溯**：每一项技术选择都能追溯到具体需求
3. **文档与代码同步**：规范文档驱动代码生成，始终保持一致
4. **快速迭代**：需求变更后几分钟即可重新生成方案，无需数天等待

这些命令将SDD理念落到实处，把规范文档从静态负担变为开发的核心驱动力。

### 模板驱动的高质量：结构化如何约束LLM输出

这些命令的真正价值，不仅在于自动化，更在于模板对LLM输出的有效引导。模板本身就是高级提示，能在关键环节对LLM加以约束：

#### 1. **防止过早涉及实现细节**

功能规格模板明确要求：
```
- ✅ 只关注用户需要什么、为什么需要
- ❌ 不涉及如何实现（不写技术栈、API、代码结构）
```

这种约束要求大模型（LLM）始终保持合适的抽象层级。比如，LLM 可能会直接跳到“用 React 和 Redux 实现”，而模板则让它聚焦于“用户需要实时数据更新”。这样一来，即使底层实现技术变化，需求规范依然保持稳定。

#### 2. **强制显式标记不确定性**

模板要求必须使用 `[NEEDS CLARIFICATION]` 标记：
```
根据用户提示生成规范时：
1. **标记所有不明确之处**：使用 [NEEDS CLARIFICATION: 具体问题]
2. **不要猜测**：如果提示未说明，必须标记
```

这样可以避免 LLM 常见的“合理但可能错误的猜测”。比如遇到“登录系统”，LLM 不能默认用邮箱/密码认证，而是要标记为 `[NEEDS CLARIFICATION: 认证方式未说明——邮箱/密码、SSO、OAuth？]`。

#### 3. **用清单推动结构化思考**

模板内置了详尽的检查清单，相当于规范的“单元测试”：
```
### 需求完整性检查
- [ ] 没有 [NEEDS CLARIFICATION] 标记残留
- [ ] 需求可测试且无歧义
- [ ] 成功标准可量化
```

这些清单促使 LLM 系统性自查，及时发现遗漏，相当于为 LLM 配备了质量保障机制。

#### 4. **通过“闸门”保障架构合规**

实现方案模板通过阶段性“闸门”强制执行架构原则：
```
### 阶段 -1：前置实施闸门
#### 简单性闸门（第七条）
- [ ] 是否只用≤3个项目？
- [ ] 是否避免超前设计？
#### 反抽象闸门（第八条）
- [ ] 是否直接使用框架？
- [ ] 是否单一模型表示？
```

这些闸门防止过度设计，LLM 必须对复杂性做出明确说明。如果闸门未通过，LLM 需在“复杂性追踪”部分记录原因，为架构决策负责。

#### 5. **分层细节管理**

模板要求合理的信息架构：
```
**重要提示**：本实现方案应保持高层次、易读性。
所有代码示例、详细算法或技术细节
必须放在 `implementation-details/` 文件中
```

这样避免了规范文档变成难以阅读的代码堆。LLM 学会把复杂细节抽离到专门文件，主文档保持清晰易查。

#### 6. **测试优先思维**

实现模板强制测试优先开发：
```
### 文件创建顺序
1. 先创建 `contracts/`，编写 API 规范
2. 按顺序创建测试文件：contract → integration → e2e → unit
3. 最后编写源码以通过测试
```

这种顺序确保 LLM 先考虑可测试性和接口契约，再动手实现，最终产出更健壮、可验证的规范。

#### 7. **杜绝臆测性功能**

模板明确禁止臆测：
```
- [ ] 不添加任何“可能需要”的功能
- [ ] 所有阶段均有明确前置条件和交付物
```

这样 LLM 不会随意添加“锦上添花”的功能，避免实现复杂化。每个功能都必须有明确的用户故事和验收标准作为依据。

### 复合效应



这些约束共同作用，确保规范具备以下特性：
- **完整性**：通过清单检查，避免遗漏任何细节
- **无歧义性**：强制澄清标记，突出不确定之处
- **可测试性**：测试优先思维贯穿始终
- **可维护性**：合理的抽象层次与信息结构
- **可实现性**：分阶段推进，每一步都有明确交付物

这些模板让大模型（LLM）从“创意写手”转变为“规范工程师”，将其能力聚焦于产出高质量、可执行、真正推动开发落地的规范文档。

## 宪法基础：保障架构规范

SDD的核心是一部“宪法”——一套不可更改的原则，规范着从需求到代码的全过程。宪法（`base/memory/constitution.md`）就像系统的基因，确保每一次实现都保持一致性、简洁性和高质量。

### 九大开发条款

宪法规定了九条基本原则，全面塑造开发流程的方方面面：

#### 第一条：库优先原则
每一个功能都必须以独立库的形式开始——无一例外。这一原则强制自顶向下的模块化设计：
```
Specify中的每个功能，必须首先以独立库的形式存在。
任何功能在抽象为可复用库组件之前，不得直接写入应用代码。
```

这样，规范生成的代码天然具备模块化和可复用性，避免形成庞大的单体应用。大模型在生成实现方案时，必须将功能拆解为边界清晰、依赖最小的库。

#### 第二条：命令行接口强制
每个库都必须通过命令行接口（CLI）暴露功能：
```
所有CLI接口必须满足：
- 支持文本输入（通过stdin、参数或文件）
- 输出文本（通过stdout）
- 结构化数据交换时支持JSON格式
```

这保证了可观测性和可测试性。大模型不能把功能藏在不透明的类里——一切都要通过文本接口对外开放、可验证。

#### 第三条：测试优先原则
最具变革意义的一条——先有测试，后写代码：
```
此条不可协商：所有实现必须严格遵循测试驱动开发（TDD）。
在满足以下条件前，不得编写实现代码：
1. 单元测试已编写
2. 测试已由用户审核通过
3. 测试已确认无法通过（Red阶段）
```

这彻底颠覆了传统AI代码生成流程。大模型必须先写出完整的测试用例，明确行为边界，获得确认后才能着手实现。

#### 第七、八条：极简与反抽象
这两条防止过度设计：
```
第7.3节：最小化项目结构
- 初始实现最多3个项目
- 增加项目需有书面理由

第8.1节：信任框架
- 直接使用框架原生功能，避免重复封装
```

当大模型倾向于引入多余抽象时，这两条会强制其为每一层复杂性给出充分理由。实现方案模板中的“Phase -1 Gates”正是对这些原则的直接约束。

#### 第九条：集成优先测试
强调真实环境下的测试优先于孤立单元测试：
```
测试必须在真实环境下进行：
- 优先使用真实数据库而非模拟
- 优先用实际服务实例而非桩代码
- 实现前必须完成契约测试
```

这样可以确保生成的代码不仅在理论上可行，在实际中也能运行。

### 通过模板实现“宪法”式约束

实施方案模板将这些条款具体化为可操作的检查点：

```markdown
### 阶段 -1：实施前关卡
#### 简单性关卡（第七条）
- [ ] 是否只用≤3个项目？
- [ ] 是否没有为未来做过度设计？

#### 反抽象关卡（第八条）
- [ ] 是否直接使用框架？
- [ ] 是否只用单一模型表示？

#### 集成优先关卡（第九条）
- [ ] 合同是否已定义？
- [ ] 合同测试是否已编写？
```

这些关卡就像架构原则的编译时检查。LLM只有通过这些关卡，或在“复杂性追踪”部分详细说明合理例外，才能继续推进。

### 不可变原则的力量

“宪法”的核心在于其不可变性。实现细节可以变化，但核心原则始终如一。这带来了：

1. **跨时间的一致性**：今天生成的代码和明年生成的代码遵循相同原则
2. **跨模型的一致性**：不同AI模型生成的代码架构兼容
3. **架构完整性**：每个新特性都在强化系统设计，而不是削弱它
4. **质量保障**：先测试、优先用库、追求简单，确保代码易维护

### 宪法的演进

虽然原则不可变，但应用方式可以演进：
```
第4.2节：修订流程
修改宪法需满足：
- 明确记录变更理由
- 项目维护者审核通过
- 评估向后兼容性
```

这样既能保持方法论的稳定，又能持续学习和改进。宪法通过带日期的修订记录自身演变，展示原则如何在实践中不断完善。

### 超越规则：开发哲学

这份宪法不仅仅是规则手册，更是一种塑造LLM代码生成思维的哲学：

- **可观测性优先于不透明性**：一切都能通过CLI接口检查
- **简单优先于巧妙**：先做简单，只有确有必要才增加复杂度
- **集成优先于孤立**：在真实环境中测试，而非虚拟环境
- **模块化优先于一体化**：每个特性都是边界清晰的库

将这些原则嵌入规范和规划流程，SDD确保生成的代码不仅能用，还易维护、易测试、架构合理。宪法让AI从代码生成器变成真正尊重并强化系统设计原则的架构伙伴。

## 变革

这不是要取代开发者，也不是自动化创造力，而是通过自动化机械性翻译来增强人的能力。它创造了一个紧密的反馈循环，让规范、研究和代码共同演进，每次迭代都让意图与实现更加契合、理解更深。

软件开发需要更好的工具来保持意图与实现的一致。SDD通过可执行规范生成代码，而不是仅仅指导代码，从而为实现这种一致性提供了方法论。